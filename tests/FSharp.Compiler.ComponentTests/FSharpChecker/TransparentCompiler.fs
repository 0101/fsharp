module FSharpChecker.TransparentCompiler

open System.Collections.Concurrent
open System.Diagnostics
open FSharp.Compiler.CodeAnalysis
open Internal.Utilities.Collections
open FSharp.Compiler.CodeAnalysis.TransparentCompiler
open Internal.Utilities.Library.Extras

open Xunit

open FSharp.Test.ProjectGeneration
open System.IO
open Microsoft.CodeAnalysis
open System
open System.Threading.Tasks


[<Fact>]
let ``Use Transparent Compiler`` () =

    let size = 20

    let project =
        { SyntheticProject.Create() with
            SourceFiles = [
                sourceFile $"File%03d{0}" []
                for i in 1..size do
                    sourceFile $"File%03d{i}" [$"File%03d{i-1}"]
            ]
        }

    let first = "File001"
    let middle = $"File%03d{size / 2}"
    let last = $"File%03d{size}"

    ProjectWorkflowBuilder(project, useTransparentCompiler = true) {
        updateFile first updatePublicSurface
        checkFile first expectSignatureChanged
        checkFile last expectSignatureChanged
        updateFile middle updatePublicSurface
        checkFile last expectSignatureChanged
        addFileAbove middle (sourceFile "addedFile" [first])
        updateFile middle (addDependency "addedFile")
        checkFile middle expectSignatureChanged
        checkFile last expectSignatureChanged
    }

[<Fact>]
let ``Parallel processing`` () =

    let project = SyntheticProject.Create(
        sourceFile "A" [],
        sourceFile "B" ["A"],
        sourceFile "C" ["A"],
        sourceFile "D" ["A"],
        sourceFile "E" ["B"; "C"; "D"])

    ProjectWorkflowBuilder(project, useTransparentCompiler = false) {
        checkFile "E" expectOk
        updateFile "A" updatePublicSurface
        saveFile "A"

        checkFile "E" expectSignatureChanged
    }

[<Fact>]
let ``Parallel processing with signatures`` () =

    let project = SyntheticProject.Create(
        sourceFile "A" [] |> addSignatureFile,
        sourceFile "B" ["A"] |> addSignatureFile,
        sourceFile "C" ["A"] |> addSignatureFile,
        sourceFile "D" ["A"] |> addSignatureFile,
        sourceFile "E" ["B"; "C"; "D"] |> addSignatureFile)

    let cacheEvents = ConcurrentBag<_>()

    ProjectWorkflowBuilder(project, useTransparentCompiler = true) {
        withChecker (fun checker -> checker.CacheEvent.Add cacheEvents.Add)
        checkFile "E" expectOk
        updateFile "A" updatePublicSurface
        checkFile "E" expectNoChanges
        regenerateSignature "A"
        regenerateSignature "B"
        regenerateSignature "C"
        regenerateSignature "D"
        regenerateSignature "E"
        checkFile "E" expectSignatureChanged
    }

let makeTestProject () =
    SyntheticProject.Create(
        sourceFile "First" [],
        sourceFile "Second" ["First"],
        sourceFile "Third" ["First"],
        { sourceFile "Last" ["Second"; "Third"] with EntryPoint = true })

let testWorkflow () =
    ProjectWorkflowBuilder(makeTestProject(), useTransparentCompiler = true)

[<Fact>]
let ``Edit file, check it, then check dependent file`` () =
    testWorkflow() {
        updateFile "First" breakDependentFiles
        checkFile "First" expectSignatureChanged
        checkFile "Second" expectErrors
    }

[<Fact>]
let ``Edit file, don't check it, check dependent file`` () =
    testWorkflow() {
        updateFile "First" breakDependentFiles
        checkFile "Second" expectErrors
    }

[<Fact>]
let ``Check transitive dependency`` () =
    testWorkflow() {
        updateFile "First" breakDependentFiles
        checkFile "Last" expectSignatureChanged
    }

[<Fact>]
let ``Change multiple files at once`` () =
    testWorkflow() {
        updateFile "First" (setPublicVersion 2)
        updateFile "Second" (setPublicVersion 2)
        updateFile "Third" (setPublicVersion 2)
        checkFile "Last" (expectSignatureContains "val f: x: 'a -> (ModuleFirst.TFirstV_2<'a> * ModuleSecond.TSecondV_2<'a>) * (ModuleFirst.TFirstV_2<'a> * ModuleThird.TThirdV_2<'a>) * TLastV_1<'a>")
    }

[<Fact>]
let ``Files depend on signature file if present`` () =
    let project = makeTestProject() |> updateFile "First" addSignatureFile

    ProjectWorkflowBuilder(project, useTransparentCompiler = true) {
        updateFile "First" breakDependentFiles
        saveFile "First"
        checkFile "Second" expectNoChanges
    }

[<Fact>]
let ``Project with signatures`` () =

    let project = SyntheticProject.Create(
        { sourceFile "First" [] with
            Source = "let f (x: int) = x"
            SignatureFile = AutoGenerated },
        { sourceFile "Second" ["First"] with
            Source = "let a x = ModuleFirst.f x"
            SignatureFile = AutoGenerated })

    ProjectWorkflowBuilder(project, useTransparentCompiler = true) {
        checkFile "Second" expectOk
    }

[<Fact>]
let ``Signature update`` () =

    let project = SyntheticProject.Create(
        { sourceFile "First" [] with
            Source = "let f (x: int) = x"
            SignatureFile = Custom "val f: x: int -> int" },
        { sourceFile "Second" ["First"] with
            Source = "let a x = ModuleFirst.f x" })

    ProjectWorkflowBuilder(project, useTransparentCompiler = true) {
        checkFile "Second" expectOk
        updateFile "First" (fun f -> { f with SignatureFile = Custom "val f: x: string -> string" })
        checkFile "Second" expectSignatureChanged
    }

[<Fact>]
let ``Adding a file`` () =
    testWorkflow() {
        addFileAbove "Second" (sourceFile "New" [])
        updateFile "Second" (addDependency "New")
        checkFile "Last" (expectSignatureContains "val f: x: 'a -> (ModuleFirst.TFirstV_1<'a> * ModuleNew.TNewV_1<'a> * ModuleSecond.TSecondV_1<'a>) * (ModuleFirst.TFirstV_1<'a> * ModuleThird.TThirdV_1<'a>) * TLastV_1<'a>")
    }

[<Fact>]
let ``Removing a file`` () =
    testWorkflow() {
        removeFile "Second"
        checkFile "Last" expectErrors
    }

[<Fact>]
let ``Changes in a referenced project`` () =
    let library = SyntheticProject.Create("library", sourceFile "Library" [])

    let project =
        { makeTestProject() with DependsOn = [library] }
        |> updateFile "First" (addDependency "Library")

    ProjectWorkflowBuilder(project, useTransparentCompiler = true) {

        updateFile "First" updatePublicSurface
        checkFile "Last" expectOk

        updateFile "Library" updatePublicSurface
        saveFile "Library"
        checkFile "Last" expectSignatureChanged

    }

[<Fact>]
let ``We don't check files that are not depended on`` () =
    let project = SyntheticProject.Create(
        sourceFile "First" [],
        sourceFile "Second" ["First"],
        sourceFile "Third" ["First"],
        sourceFile "Last" ["Third"])

    let cacheEvents = ResizeArray()

    ProjectWorkflowBuilder(project, useTransparentCompiler = true) {
        withChecker (fun checker ->
            async {
                do! Async.Sleep 50 // wait for events from initial project check
                checker.CacheEvent.Add cacheEvents.Add
            })
        updateFile "First" updatePublicSurface
        checkFile "Last" expectOk
    } |> ignore

    let intermediateTypeChecks =
        cacheEvents
        |> Seq.choose (function
            | ("TcIntermediate", e, k) -> Some ((k :?> FSharpProjectSnapshotKey).LastFile |> fst |> Path.GetFileName, e)
            | _ -> None)
        |> Seq.groupBy fst
        |> Seq.map (fun (k, g) -> k, g |> Seq.map snd |> Seq.toList)
        |> Map

    Assert.Equal<JobEventType list>([Started; Finished], intermediateTypeChecks["FileFirst.fs"])
    Assert.Equal<JobEventType list>([Started; Finished], intermediateTypeChecks["FileThird.fs"])
    Assert.False (intermediateTypeChecks.ContainsKey "FileSecond.fs")

[<Fact>]
let ``Files that are not depended on don't invalidate cache`` () =
    let project = SyntheticProject.Create(
        sourceFile "First" [],
        sourceFile "Second" ["First"],
        sourceFile "Third" ["First"],
        sourceFile "Last" ["Third"])

    let cacheEvents = ResizeArray()

    ProjectWorkflowBuilder(project, useTransparentCompiler = true) {
        updateFile "First" updatePublicSurface
        checkFile "Last" expectOk
        withChecker (fun checker ->
            async {
                do! Async.Sleep 50 // wait for events from initial project check
                checker.CacheEvent.Add cacheEvents.Add
            })
        updateFile "Second" updatePublicSurface
        checkFile "Last" expectOk
    } |> ignore

    let intermediateTypeChecks =
        cacheEvents
        |> Seq.choose (function
            | ("TcIntermediate", e, k) -> Some ((k :?> FSharpProjectSnapshotKey).LastFile |> fst |> Path.GetFileName, e)
            | _ -> None)
        |> Seq.groupBy fst
        |> Seq.map (fun (k, g) -> k, g |> Seq.map snd |> Seq.toList)
        |> Map

    let graphConstructions =
        cacheEvents
        |> Seq.choose (function
            | ("DependencyGraph", e, k) -> Some ((k :?> (FSharpFileKey list * DependencyGraphType)) |> fst |> List.last |> fst |> Path.GetFileName, e)
            | _ -> None)
        |> Seq.groupBy fst
        |> Seq.map (fun (k, g) -> k, g |> Seq.map snd |> Seq.toList)
        |> Map

    Assert.Equal<JobEventType list>([Started; Finished], graphConstructions["FileLast.fs"])

    Assert.Equal<string * JobEventType list>([], intermediateTypeChecks |> Map.toList)

[<Fact>]
let ``Files that are not depended on don't invalidate cache part 2`` () =
    let project = SyntheticProject.Create(
        sourceFile "A" [],
        sourceFile "B" ["A"],
        sourceFile "C" ["A"],
        sourceFile "D" ["B"; "C"],
        sourceFile "E" ["C"])

    let cacheEvents = ResizeArray()

    ProjectWorkflowBuilder(project, useTransparentCompiler = true) {
        updateFile "A" updatePublicSurface
        checkFile "D" expectOk
        withChecker (fun checker ->
            async {
                do! Async.Sleep 50 // wait for events from initial project check
                checker.CacheEvent.Add cacheEvents.Add
            })
        updateFile "B" updatePublicSurface
        checkFile "E" expectOk
    } |> ignore

    let intermediateTypeChecks =
        cacheEvents
        |> Seq.choose (function
            | ("TcIntermediate", e, k) -> Some ((k :?> FSharpProjectSnapshotKey).LastFile |> fst |> Path.GetFileName, e)
            | _ -> None)
        |> Seq.groupBy fst
        |> Seq.map (fun (k, g) -> k, g |> Seq.map snd |> Seq.toList)
        |> Seq.toList

    let graphConstructions =
        cacheEvents
        |> Seq.choose (function
            | ("DependencyGraph", e, k) -> Some ((k :?> (FSharpFileKey list * DependencyGraphType)) |> fst |> List.last |> fst |> Path.GetFileName, e)
            | _ -> None)
        |> Seq.groupBy fst
        |> Seq.map (fun (k, g) -> k, g |> Seq.map snd |> Seq.toList)
        |> Seq.toList

    Assert.Equal<string * JobEventType list>(["FileE.fs", [Started; Finished]], graphConstructions)
    Assert.Equal<string * JobEventType list>(["FileE.fs", [Started; Finished]], intermediateTypeChecks)


[<Theory>]
[<InlineData true>]
[<InlineData false>]
let ``Multi-project`` signatureFiles =

    let sigFile = if signatureFiles then AutoGenerated else No

    let library = SyntheticProject.Create("library",
        { sourceFile "LibA" []
            with
                Source = "let f (x: int) = x"
                SignatureFile = sigFile },
        { sourceFile "LibB" ["LibA"] with SignatureFile = sigFile },
        { sourceFile "LibC" ["LibA"] with SignatureFile = sigFile },
        { sourceFile "LibD" ["LibB"; "LibC"] with SignatureFile = sigFile }
        )

    let project =
        { SyntheticProject.Create("app",
            sourceFile "A" ["LibB"],
            sourceFile "B" ["A"; "LibB"],
            sourceFile "C" ["A"; "LibC"],
            sourceFile "D" ["A"; "LibD"]
            )
          with DependsOn = [library] }

    ProjectWorkflowBuilder(project, useTransparentCompiler = true) {
        updateFile "LibA" updatePublicSurface
        checkFile "D" expectOk
    }


type ProjectAction = Get | Modify of (SyntheticProject -> SyntheticProject)
type ProjectModificaiton = Update of int | Add | Remove
type ProjectRequest = ProjectAction * AsyncReplyChannel<SyntheticProject>

[<RequireQualifiedAccess>]
type SignatureFiles = Yes = 1 | No = 2 | Some = 3

[<Theory>]
[<InlineData(SignatureFiles.Yes)>]
[<InlineData(SignatureFiles.No)>]
[<InlineData(SignatureFiles.Some)>]
let Fuzzing signatureFiles =
    let seed = System.Random().Next()
    //let seed = 1093747864
    let rng = System.Random(int seed)

    let fileCount = 20
    let maxDepsPerFile = 3
    let checkingThreads = 16
    let maxModificationDelayMs = 50
    let maxCheckingDelayMs = 5
    let runTimeMs = 10000
    let signatureFileModificationProbability = 0.25

    let fileName i = sprintf $"F%03d{i}"

    //let extraCode = __SOURCE_DIRECTORY__ ++ ".." ++ ".." ++ ".." ++ "src" ++ "Compiler" ++ "Utilities" ++ "EditDistance.fs" |> File.ReadAllLines |> Seq.skip 5 |> String.concat "\n"
    let extraCode = ""

    let files =
        [| for i in 1 .. fileCount do
            let name = fileName i
            let deps = [
                for _ in 1 .. maxDepsPerFile do
                    if i > 1 then
                      fileName <| rng.Next(1, i) ]
            let signature = 
                match signatureFiles with
                | SignatureFiles.Yes -> AutoGenerated
                | SignatureFiles.Some when rng.NextDouble() < 0.5 -> AutoGenerated 
                | _ -> No

            { sourceFile name deps 
                with 
                    SignatureFile = signature
                    ExtraSource = extraCode }
        |]

    let initialProject = SyntheticProject.Create("TCFuzzing", files)

    let builder = ProjectWorkflowBuilder(initialProject, useTransparentCompiler = true, autoStart = false)
    let checker = builder.Checker

    let initialProject = initialProject |> absorbAutoGeneratedSignatures checker |> Async.RunSynchronously

    let projectAgent = MailboxProcessor.Start(fun (inbox: MailboxProcessor<ProjectRequest>) ->
        let rec loop project =
            async {
                let! action, reply = inbox.Receive()
                let! project =
                    match action with
                    | Modify f -> async { 
                        let p = f project
                        do! saveProject p false checker 
                        return p }
                    | Get -> async.Return project
                reply.Reply project
                return! loop project
            }
        loop initialProject)

    let getProject () =
        projectAgent.PostAndAsyncReply(pair Get)

    let modifyProject f =
        projectAgent.PostAndAsyncReply(pair(Modify f)) |> Async.Ignore

    let modificationProbabilities = [
        Update 1, 80
        Update 2, 5
        Update 10, 5
        Add, 2
        Remove, 1
    ]

    let modificationPicker = [|
        for op, prob in modificationProbabilities do
            for _ in 1 .. prob do
                op
    |]

    let addComment s = $"{s}\n\n// {rng.NextDouble()}"
    let modifyImplFile f = { f with ExtraSource = f.ExtraSource |> addComment }
    let modifySigFile f = { f with SignatureFile = Custom (f.SignatureFile.CustomText |> addComment) }

    let getRandomModification () = modificationPicker[rng.Next(0, modificationPicker.Length)]

    let getRandomFile (project: SyntheticProject) = project.SourceFiles[rng.Next(0, project.SourceFiles.Length)].Id

    let log = ConcurrentBag()

    let modificationLoop = async {
        while true do
            do! Async.Sleep (rng.Next maxModificationDelayMs)
            let modify project =
                match getRandomModification() with
                | Update n ->
                    let files = Set [ for _ in 1..n -> getRandomFile project ]
                    (project, files)
                    ||> Seq.fold (fun p fileId -> 
                        let project, file = project.FindInAllProjects fileId
                        let opName, f = 
                            if file.HasSignatureFile && rng.NextDouble() < signatureFileModificationProbability 
                            then nameof modifySigFile, modifySigFile
                            else nameof modifyImplFile, modifyImplFile
                        log.Add $"{project.Name} -> {fileId} |> {opName}"
                        p |> updateFileInAnyProject fileId f)
                | Add
                | Remove ->
                    // TODO:
                    project
            do! modifyProject modify
    }
    
    let checkingLoop = async {
        while true do
            let! project = getProject()
            let file = project |> getRandomFile

            // TODO: timeout & cancelation
            log.Add $"Started checking {file}"
            let! result = checker |> checkFile file project 
            
            log.Add $"Checked {file} %A{snd result}"
            expectOk result ()

            do! Async.Sleep (rng.Next maxCheckingDelayMs)
    }

    async {
        let! threads = 
            seq { 
                Async.StartChild(modificationLoop, runTimeMs) 
                ignore modificationLoop
                for _ in 1..checkingThreads do 
                    Async.StartChild(checkingLoop, runTimeMs)
            }
            |> Async.Parallel 
        try 
            do! threads |> Async.Parallel |> Async.Ignore
        with 
            | :? TimeoutException
            | :? TaskCanceledException -> ()
            | :? AggregateException as e when e.InnerExceptions |> Seq.exists (fun e -> e :? TaskCanceledException) -> ()
            | e -> failwith $"Seed: {seed}\nException: %A{e}"
    } |> Async.RunSynchronously

    //builder.DeleteProjectDir()


[<Theory>]
[<InlineData true>]
[<InlineData false>]
let GiraffeFuzzing signatureFiles =
    let seed = System.Random().Next()
    //let seed = 1093747864
    let rng = System.Random(int seed)

    let checkingThreads = 32
    let maxModificationDelayMs = 100
    let maxCheckingDelayMs = 5
    let runTimeMs = 20000
    let signatureFileModificationProbability = 0.25

    let giraffe = if signatureFiles then "giraffe-signatures" else "Giraffe"
    let giraffeDir = __SOURCE_DIRECTORY__ ++ ".." ++ ".." ++ ".." ++ ".." ++ giraffe ++ "src" ++ "Giraffe"

    let initialProject = SyntheticProject.CreateFromRealProject giraffeDir
    let initialProject = { initialProject with OtherOptions = "--nowarn:FS3520"::initialProject.OtherOptions }

    let builder = ProjectWorkflowBuilder(initialProject, useTransparentCompiler = true, autoStart = false)
    let checker = builder.Checker

    // Force creation and caching of options
    SaveAndCheckProject initialProject checker |> Async.Ignore |> Async.RunSynchronously

    let projectAgent = MailboxProcessor.Start(fun (inbox: MailboxProcessor<ProjectRequest>) ->
        let rec loop project =
            async {
                let! action, reply = inbox.Receive()
                let! project =
                    match action with
                    | Modify f -> async { 
                        let p = f project
                        do! saveProject p false checker 
                        return p }
                    | Get -> async.Return project
                reply.Reply project
                return! loop project
            }
        loop initialProject)

    let getProject () =
        projectAgent.PostAndAsyncReply(pair Get)

    let modifyProject f =
        projectAgent.PostAndAsyncReply(pair(Modify f)) |> Async.Ignore

    let modificationProbabilities = [
        Update 1, 80
        Update 2, 5
        Update 10, 5
        //Add, 2
        //Remove, 1
    ]

    let modificationPicker = [|
        for op, prob in modificationProbabilities do
            for _ in 1 .. prob do
                op
    |]

    let addComment s = $"{s}\n\n// {rng.NextDouble()}"
    let modifyImplFile f = { f with ExtraSource = f.ExtraSource |> addComment }
    let modifySigFile f = { f with SignatureFile = Custom (f.SignatureFile.CustomText |> addComment) }

    let getRandomModification () = modificationPicker[rng.Next(0, modificationPicker.Length)]

    let getRandomFile (project: SyntheticProject) = project.SourceFiles[rng.Next(0, project.SourceFiles.Length)].Id

    let log = ConcurrentBag()

    let modificationLoop = async {
        while true do
            do! Async.Sleep (rng.Next maxModificationDelayMs)
            let modify project =
                match getRandomModification() with
                | Update n ->
                    let files = Set [ for _ in 1..n -> getRandomFile project ]
                    (project, files)
                    ||> Seq.fold (fun p fileId -> 
                        let project, file = project.FindInAllProjects fileId
                        let opName, f = 
                            if file.HasSignatureFile && rng.NextDouble() < signatureFileModificationProbability 
                            then nameof modifySigFile, modifySigFile
                            else nameof modifyImplFile, modifyImplFile
                        log.Add $"{DateTime.Now.ToShortTimeString()}| {project.Name} -> {fileId} |> {opName}"
                        p |> updateFileInAnyProject fileId f)
                | Add
                | Remove ->
                    // TODO:
                    project
            do! modifyProject modify
    }
    
    let checkingLoop n = async {
        while true do
            let! project = getProject()
            let file = project |> getRandomFile

            // TODO: timeout & cancelation
            log.Add $"{DateTime.Now.ToShortTimeString()}| #{n} Started checking {file}"
            let! result = checker |> checkFile file project 
            
            log.Add $"{DateTime.Now.ToShortTimeString()}| #{n} Checked {file} %A{snd result}"
            expectOk result ()

            do! Async.Sleep (rng.Next maxCheckingDelayMs)
    }

    async {
        let! threads = 
            seq { 
                Async.StartChild(modificationLoop, runTimeMs) 
                ignore modificationLoop
                for n in 1..checkingThreads do 
                    Async.StartChild(checkingLoop n, runTimeMs)
            }
            |> Async.Parallel 
        try 
            do! threads |> Async.Parallel |> Async.Ignore
        with 
            | :? TimeoutException
            | :? TaskCanceledException -> ()
            | :? AggregateException as e when e.InnerExceptions |> Seq.exists (fun e -> e :? TaskCanceledException) -> ()
            | e -> failwith $"Seed: {seed}\nException: %A{e}"
    } |> Async.RunSynchronously

    builder.DeleteProjectDir()
    ()
